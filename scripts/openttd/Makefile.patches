#
# Checking and applying patches against trunk or specified sources
# @author Andrey Zakharov /2010/
#
.PHONY : all clean trunk-prepare tp patching-building trunk-clean trunk-update clean run

.NOTPARALLEL :



#
#defaults
#
include Mk.params
# TODO openttd specific out to profiles?
PACKNAME=vs_hard_pack
PARAM ?= "--dry-run"
TRUNK ?= ~/src/openttd/svn.openttd.org/trunk
MODE ?= alone # or patchpack
BROWSER ?= cat #opens final result
BROWSERI ?= cat # pipes
PATCHDIR ?= $(shell pwd)
PATCHMAP ?= ${PATCHDIR}/Mk.patchtable
PATCHES ?= rating_town_label station-build-gui_v5.1 openttd-cargodist-minipack harder_game IB
# TimeOut in secs
HTTP_TO ?= 30
DNS_TO ?= 2
DONE = @echo "==> $@ DONE"
FAILREPORT = ( ($(BROWSER) $< $@ &) && (find $(TRUNK) -name *.rej | xargs $(BROWSER) &)
#
# Utils
#

# revision
# TODO as file REVISION.txt
REV := r$(shell cd ${TRUNK} && svnversion -n)
.PRECIOUS : ${PATCHDIR}/%.patch %.patch.log %.build.log ${PATCHDIR}/%.patch.${REV}

original_patch_name = $(shell echo "$@" | sed 's!_r[0-9]\+.*!.patch!')

#
# Gets the number of ignorable prefixes in unified patch
# Internal, skip this!
# 1. find "--- PATH"
# 2. see if this available
# 3. p++ goto 1
find_ignorable_prefix = $$(\
	for f in `awk '/^---(.*)$$/ { print $$2 }' $<`; do \
	  i=0; f2c="$$f"; \
	  if [ -r "${TRUNK}/$$f2c" ]; then echo $$i; exit 0; fi; \
	  while [ -n "$$f2c" ]; do \
	      i=`expr $$i + 1`; \
	      nf2c=`echo $$f2c | sed 's!^[^/]*/!!'`; \
	      if [ x"$$nf2c" = x"$$f2c" ]; then echo 0; exit 1; fi; \
	      f2c=$$nf2c; \
	      if [ -r "${TRUNK}/$$f2c" ]; then echo $$i; exit 0; fi; \
	  done; \
	done; )
# do it better by GNU make itself TODO

# start of easy part
all : $(PACKNAME).patch.check ${PATCHDIR}/$(PACKNAME).patch.${REV}
	$(DONE)
	( $(BROWSER) ${PATCHDIR}/$(PACKNAME).patch.${REV} )

$(TRUNK)/Makefile:
	( cd $(TRUNK); ./configure > /dev/null )

# 
# Making auto patch file
# Do patch from current trunk
# $(PACKNAME).patch.${REV} will be caught by this
${PATCHDIR}/%.patch.${REV} : trunk-sweep
	( cd $(TRUNK) && svn status | grep -v M |grep -v bin/|  awk '{print $$2}' | xargs svn add || true )
	( cd ${TRUNK} && svn --extensions '--ignore-space-change --ignore-all-space' diff > "$@" )

# for quick hack, we do not require %.build.log 
%.save : ${PATCHDIR}/%.patch.${REV} #alias
	$(DONE) 
# report here of diffs with previois patch

# override common rule by this one
#${PATCHDIR}/$(PACKNAME).patch.${REV} : ${PATCHDIR}/$(PACKNAME).build.log  trunk-sweep 

$(PACKNAME).build.log : patching-building reporting
	$(DONE)

##
# Preparing, cleaning & sweeping
#
tp :trunk-prepare

trunk-prepare  : trunk-sweep trunk-revert trunk-clean trunk-update #alias
	$(DONE)

trunk-revert : 
	( cd $(TRUNK) && svn -R revert . )

#sweep our mess
trunk-sweep:
	( find $(TRUNK) -name \*rej -or -name \*orig -or -name \.~\*bak | xargs rm --force --verbose )
	@echo $(REV) was sweeped

trunk-clean :
	( if [ -f $(TRUNK)/Makefile ]; then $(MAKE) -f Makefile -C $(TRUNK) clean >/dev/null; fi )
#deep svn new files from patches clean
	( cd $(TRUNK) && svn stat | grep ^? | grep -v 'nbproject\|Makefile-trunk.mk\|bin/' | xargs rm -rf )
	@echo $(REV)

trunk-update : 
	( cd $(TRUNK) && svn update )
#    RVER=$(svnversion -n)

clean : 
	( rm *.log || true )
	$(DONE)

distclean : 
	( rm *.patch.$(REV) )
	$(DONE)

sweep : $(addsuffix .sweep, $(PATCHES) )
	$(DONE)

%.sweep :
	@echo "==> Sweeping $*..."
	( rm $*.patch || true )
	$(DONE)

run :
	$(MAKE) run -C $(TRUNK)

reset: clean trunk-prepare
	$(DONE)

list :
	@( awk '/^\w/ { print $$1 }' ${PATCHMAP} | tail -n+2|sort)

# end of easy part

#
# Separate 
# * patchpack,
# * alone (patching and building patches alone one-by-one from list),
# * increment (patching and build-check one, then add next one, and so on
ifeq (${MODE},patchpack)

patching-building : $(addsuffix .patch.log, $(PATCHES) )
	@echo "==> Buildin $*..."
ifeq ($(findstring --dry-run,${PARAM}),)
#	( $(MAKE) -C $(TRUNK) clean )
	( $(MAKE) -C $(TRUNK) all > $@ )
else
	@echo "!!! Skipping /$(PARAM)/. To perform real build exec:"
	@echo "                  $$ PARAM=\"\" $(MAKE) all"
endif
	$(DONE)


else ifeq (${MODE},alone)
patching-building : $(addprefix trunk-prepare ,$(addsuffix .patch.check, $(PATCHES) ))
	@echo "==> Alone checking all patches DONE."


else
patching-building : $(addprefix increment ,$(addsuffix .patch.check, $(PATCHES) ))
	@echo "==> Increment checking all patches DONE."

endif

# here construct txt report
reporting: 
	$(DONE)

increment :
	@echo "==> Incrementing..."

##
# Patchworks
#
%.patch.log : ${PATCHDIR}/%.patch
	@echo "==> Patchin $*..."
	@( test -f $< )
ifeq ($(findstring --dry-run,${PARAM}),)
	@( patch $(PARAM) --directory=${TRUNK} --forward --force --fuzz=3 --strip=${find_ignorable_prefix} --input="$<" > $@ ) || \
		$(FAILREPORT) && false )
else
	@( patch $(PARAM) --directory=${TRUNK} --forward --force --fuzz=3 --strip=${find_ignorable_prefix} --input="$<" )
endif
	@echo "==> Patchin $* DONE"

# runs configure after patching? or not? who cares
%.build.log : %.patch.log $(TRUNK)/Makefile
	@echo "==> Buildin $*..."
ifeq ($(findstring --dry-run,${PARAM}),)
#ifeq ($(findstring forceclean,${PARAM}),)
#	( $(MAKE) -C $(TRUNK) clean )
	( $(MAKE) -C $(TRUNK) all > $@ )
else
	@echo "!!! Skipping /$(PARAM)/. To perform real build exec:"
	@echo "                  $ PARAM=\"\" $(MAKE) all"
endif
	@echo "==> Buildin $* DONE"
	
%.patch.check : %.build.log ${PATCHDIR}/%.patch.${REV}
	$(DONE)
%.patch.check : %.build.log ${PATCHDIR}/%.patch.${REV}
	$(DONE)



# Refresh patch file from its URL
${PATCHDIR}/%.patch : #  here TODO from local saved file by currev-1,currev+1,currev-2,currev+2...
	@echo "==> Refreshing $*..." 
	@( awk '/^$*/ { print $$2 }' ${PATCHMAP} )
	wget --output-document="${PATCHDIR}/$*.patch" \
		--no-clobber --timeout=$(HTTP_TO) --dns-timeout=$(DNS_TO) -- \
		"$(shell awk '/^$*[ ]+/ { print $$2 }' ${PATCHMAP})"


SRCDIR := $(shell dirname ${TRUNK})
%.new :
	( cd $(SRCDIR) && \
	  svn checkout svn://svn.openttd.org/tags/$*/ $* && \
	  echo "Don't forget to change TRUNK=\"$(SRCDIR)/$*\"!")

