#
# Checking and applying patches against trunk or specified sources
# @author Andrey Zakharov /2010-2011/ http://vaultsoft.info
#

# Usage:
#  show patchpack patches list
#   make list
#  try to patch all patches
#   make
#  to check one by one set of patches
#   PATCHES="patch1 patch2" MODE=alone PARAM='' make
#  to make patchpack
#   PARAM='' make clean trunk-prepare all
#  make clean trunk-prepare && make PARAM='' all; make PARAM='' all


.PHONY : all clean trunk-prepare tp patching-building trunk-sweep trunk-clean trunk-update clean run pp

.NOTPARALLEL :

location = $(word $(words $(MAKEFILE_LIST)),$(MAKEFILE_LIST))
whoami := $(location)

#
#defaults
#
include Mk.params
# TODO openttd specific out to profiles?
PACKNAME ?= vs_hard_pack
LANG ?= ru
PARAM ?= "--dry-run"
TRUNK ?= $(HOME)/src/openttd/trunk
WORKDIR ?= ./
MODE ?= alone # or patchpack
BROWSER ?= cat #opens final result
PATCHDIR ?= $(shell pwd)
PATCHMAP ?= $(PATCHDIR)/Mk.patchtable
PATCHES ?= $(shell cat patchpack.txt)
CONFIGURE_PARAMS +=
BUNDLE_OVERLAP ?= $(PATCHDIR)/../bundle
DOS2UNIXPATH ?= sed 's\#\\\\\#/\#g'
# TimeOut in secs
HTTP_TO ?= 30
DNS_TO ?= 2
DONE = @echo "==> $@ DONE"
FAILREPORT = ( ($(BROWSER) $< $@ &) && (find $(TRUNK) -name *.rej | xargs $(BROWSER) &) && ( grep "FAILED --" $< | $(BROWSER) )
Q ?= @
TRUNKTARGETREV ?= -rHEAD

#
# Utils
#

# revision
VERSION := 0.6
# TODO as file REVISION.txt

#REV := $(shell cd ${TRUNK} && ./findversion.sh | awk '{ sub( /M/,"" , $$1 ); print $$1 }')
#REV := $(VERSION).$(shell cd ~/scripts/openttd && svnversion -n)
REV := $(VERSION).$(shell cd ${WORKDIR} && svnversion -n)
TRUNKREV := r$(shell cd ${TRUNK} && svnversion -n)
.PRECIOUS: ${PATCHDIR}/%.patch %.patch.log %.build.log ${PATCHDIR}/%.patch.${REV}

original_patch_name = $(shell echo "$@" | sed 's!_r[0-9]\+.*!.patch!')

#
# Gets the number of ignorable prefixes in unified patch
# Internal, skip this!
# 1. find "--- PATH"
# 2. see if this available
# 3. p++ goto 1
find_ignorable_prefix = $$(\
	for f in `awk '/^---(.*)$$/ { print $$2 }' $<`; do \
	  i=0; f2c="$$f"; \
	  if [ "x$$f2c" == "x/dev/null" ]; then continue; fi; \
	  if [ -r "${TRUNK}/$$f2c" ]; then echo $$i; exit 0; fi; \
	  while [ -n "$$f2c" ]; do \
	      i=`expr $$i + 1`; \
	      nf2c=`echo $$f2c | sed 's!^[^/]*/!!'`; \
	      if [ x"$$nf2c" = x"$$f2c" ]; then echo 0; exit 1; fi; \
	      f2c=$$nf2c; \
	      if [ -r "${TRUNK}/$$f2c" ]; then echo $$i; exit 0; fi; \
	  done; \
	done; )
# do it better by GNU make itself TODO

# start of easy part
all : $(PACKNAME).patch.check ${PATCHDIR}/$(PACKNAME).patch.${REV}
	@echo "==> $@ DONE"
	( $(BROWSER) ${PATCHDIR}/$(PACKNAME).patch.${REV} )

$(TRUNK)/Makefile:
	( cd $(TRUNK); ./configure $(CONFIGURE_PARAMS) > /dev/null )

pp:
	$(Q)( make clean trunk-prepare )
#	IB, progwaypoint, improved-loans failed on saveload export BROWSER=cat; 
	$(Q)( $(MAKE) all; $(MAKE) all; $(MAKE) all; $(MAKE) all )
	
# 
# Making auto patch file
# Do patch from current trunk
# $(PACKNAME).patch.${REV} will be caught by this
${PATCHDIR}/%.patch.${REV} : trunk-sweep trunk-generate
	$(Q)( cd $(TRUNK) && svn status | $(DOS2UNIXPATH) | grep -v ^\[M\|A\] |grep -v 'nbproject\|Makefile-trunk.mk\|bin/'|  awk '{print $$2}' | xargs svn add || true )
	$(Q)([ x"$*" != x"$(PACKNAME)" ]) && ( cd $(TRUNK) && svn revert src/saveload/saveload.cpp ) || true
	$(Q)( cd ${TRUNK} && svn --extensions '--ignore-space-change --ignore-all-space' diff > "$@" )

${PATCHDIR}/%.patch.${TRUNKREV} : trunk-sweep trunk-generate
	$(Q)( cd $(TRUNK) && svn status | $(DOS2UNIXPATH) | grep -v ^\[M\|A\] |grep -v 'nbproject\|Makefile-trunk.mk\|bin/'|  awk '{print $$2}' | xargs svn add || true )
	$(Q)( cd ${TRUNK} && svn --extensions '--ignore-space-change --ignore-all-space' diff > "$@" )

# for quick hack, we do not require %.build.log 
%.save : ${PATCHDIR}/%.patch.${TRUNKREV} ${PATCHDIR}/%.patch.${REV} #alias
	$(Q)( mkdir -p ${PATCHDIR}/${VERSION}/ ) # mkdir ./patches/0.4
	$(Q)( mv --interactive ${PATCHDIR}/$*.patch.${TRUNKREV} ${PATCHDIR}/${VERSION}/$*.${TRUNKREV}.patch ) # mv p.patch.0.4.110 patches/0.4/p.patch.0.4.110
	$(Q)( mv --force ${PATCHDIR}/$*.patch.${REV} ${PATCHDIR}/${VERSION}/$*.${REV}.${TRUNKREV}.patch ) # mv p.patch.0.4.110 patches/0.4/p.patch.0.4.110
	$(Q)( cd ${PATCHDIR}; ln --symbolic --force ${VERSION}/$*.${REV}.${TRUNKREV}.patch $*.patch ) # sym link it
	$(Q)( ls -la ${PATCHDIR}/$*.patch )
	$(DONE)
#report here of diffs with previois patch

# override common rule by this one
#${PATCHDIR}/$(PACKNAME).patch.${REV} : ${PATCHDIR}/$(PACKNAME).build.log  trunk-sweep 

$(PACKNAME).build.log : patching-building reporting
	$(DONE)

##
# Preparing, cleaning & sweeping
#
tp :trunk-prepare

trunk-prepare  : trunk-sweep trunk-revert trunk-clean trunk-update #alias
	$(DONE)

trunk-revert : 
	$(Q)( cd $(TRUNK) && svn -R revert . )
	@echo [SRC] $(TRUNKREV) reverted

#sweep our mess
trunk-sweep:
	$(Q)( find $(TRUNK) -name \*rej -or -name \*orig -or -name \.~\*bak | xargs rm --force --verbose -- )
	@echo [SRC] $(TRUNKREV) swept

trunk-clean :
	$(Q)( if [ -f $(TRUNK)/Makefile ]; then $(MAKE) -f Makefile -C $(TRUNK) clean >/dev/null; fi )
#deep svn new files from patches clean
	$(Q)( cd $(TRUNK) && svn stat | $(DOS2UNIXPATH)  |  grep ^? | grep -v 'nbproject\|Makefile-trunk.mk\|bin/' | xargs rm -rf -- )
	@echo [SRC] $(TRUNKREV) clean

trunk-update : 
	$(Q)( cd $(TRUNK) && svn update $(TRUNKTARGETREV))
#    RVER=$(svnversion -n)

# generate project files
trunk-generate:
	$(Q)( cd $(TRUNK) && sh projects/generate )

post-patches-prepare:
	mkdir -p $(TRUNK).patched
	rsync -av --exclude=/bin --exclude=/docs --exclude=/objs --exclude=.svn --exclude=/bundle --exclude=/bundles --exclude='**.orig' --exclude-from=$(TRUNK)/.hgignore $(TRUNK)/ $(TRUNK).patched/

post-patches-make:
	diff -wur -x .dep.inc -x bin -x objs -x .svn -x bundle -x bundles -x *.orig $(TRUNK).patched/ --exclude-from=$(TRUNK)/.hgignore $(TRUNK)/ | grep -v Только

clean : 
	$(Q)( rm *.log || true )
	$(DONE)

distclean : 
	( rm *.patch.$(REV) )
	$(DONE)

sweep : $(addsuffix .sweep, $(PATCHES) )
	$(DONE)

%.sweep :
	@echo "==> Sweeping $*..."
	$(Q)( rm ${PATCHDIR}/$*.patch || true )
	$(DONE)

run :
	$(MAKE) run -C $(TRUNK)

run-srv:
	$(TRUNK)/bin/openttd -D -f
	$(TRUNK)/bin/openttd -n 127.0.0.1:3979

reset: clean trunk-prepare
	$(DONE)

list :
	$(Q)( awk '/^\w/ { print $$1 }' ${PATCHMAP} | tail -n+2|sort)

plan:
	$(Q)( echo $(PATCHES) )

# end of easy part

patchpack-versions: 
	( sed '/openttd_revision\[\]/ s!".*"!"HardPack-$(REV)"!g' $(TRUNK)/src/rev.cpp.in > rev.cpp.in.tmp )
	( mv rev.cpp.in.tmp $(TRUNK)/src/rev.cpp.in )

#
# Separate 
# * patchpack,
# * alone (patching and building patches alone one-by-one from list),
# * increment (patching and build-check one, then add next one, and so on
ifeq (${MODE},patchpack)
patching: $(addsuffix .patch.log, $(PATCHES)) patchpack-versions
	@echo "==> Patchpack patches DONE."

else ifeq (${MODE},alone)
patching: $(addprefix trunk-prepare ,$(addsuffix .patch.check, $(filter-out post-patches%,$(PATCHES)) ))
	@echo "==> Alone checking all patches DONE."

else
patching: $(addprefix increment ,$(addsuffix .patch.check, $(filter-out post-patches%,$(PATCHES)) ))
	@echo "==> Increment checking all patches DONE."

endif

building: $(TRUNK)/Makefile
	@echo "==> Buildin $*..."
ifeq ($(findstring --dry-run,${PARAM}),)
# changing dir for possible reconfigure, but we do not know initial path too
# also this is hack to pre-reconfigure by "make" not $(MAKE) which can be mingw32-make.exe
	( make $(MFLAGS) -C $(TRUNK) all >$@ )
else
	@echo "!!! Skipping /$(PARAM)/. To perform real build exec:"
	@echo "                  $$ PARAM=\"\" $(MAKE) all"
endif
	$(DONE)

# and all together
patching-building: patching building
	$(DONE)
# here construct txt report
reporting: 
	$(DONE)

increment :
	@echo "==> Incrementing..."

##
# Patchworks
#
%.patch.log : ${PATCHDIR}/%.patch
	@echo -n "==> Patchin $*..."
	$(Q)( test -f $< )
ifeq ($(findstring --dry-run,${PARAM}),)
	$(Q)( patch $(PARAM) --forward --force --fuzz=3 --directory="${TRUNK}" --strip=${find_ignorable_prefix} --input="$<" > $@ ) || \
		$(FAILREPORT) && false )
else
	$(Q)( patch $(PARAM) --forward --force --fuzz=3 --directory="${TRUNK}" --strip=${find_ignorable_prefix} --input="$<" )
endif
	@echo "OK"

# runs configure after patching? or not? who cares
%.build.log : %.patch.log $(TRUNK)/Makefile 
	@echo "==> Buildin $*..."
ifeq ($(findstring --dry-run,${PARAM}),)
# changing dir for possible reconfigure, but we do not know initial path too
#ifeq ($(findstring forceclean,${PARAM}),)
#	( $(MAKE) -C $(TRUNK) clean )
# also this is hack to pre-reconfigure by "make" not $(MAKE) which can be mingw32-make.exe
	$(Q)( make $(MFLAGS) -C $(TRUNK) all >$@ )
else
	@echo "!!! Skipping /$(PARAM)/. To perform real build exec:"
	@echo "                  $ PARAM=\"\" $(MAKE) all"
endif
	@echo "==> Buildin $* DONE"

%.patch.check : %.build.log ${PATCHDIR}/%.patch.${REV}
	$(DONE)



# Refresh patch file from its URL
#  here TODO from local saved file by currev-1,currev+1,currev-2,currev+2...
${PATCHDIR}/%.patch : 
	@echo "==> Refreshing $@..." 
	@( awk '/^$*/ { print $$2 }' ${PATCHMAP} )
	wget --output-document="$@" \
		--no-clobber --timeout=$(HTTP_TO) --dns-timeout=$(DNS_TO) --no-check-certificate -- \
		"$(shell awk '/^$*[ ]+/ { print $$2 }' ${PATCHMAP})"


SRCDIR := $(shell dirname ${TRUNK})
%.new :
	( cd $(SRCDIR) && \
	  svn checkout svn://svn.openttd.org/tags/$*/ $* && \
	  echo "Don't forget to change TRUNK=\"$(SRCDIR)/$*\"!")
	 
BUNDLE_DIR =  $(TRUNK)/bundle
BUNDLES_DIR = $(TRUNK)/bundles
BUNDLE_NAME = openttd-hardpack-$(REV)
bundle :
	@( make $(MFLAGS) -C "$(TRUNK)" bundle )
	( [ -n "$(BUNDLE_OVERLAP)" -a -d "$(BUNDLE_OVERLAP)" ] && \
	  cp -R --force --target-directory="$(TRUNK)/bundle" "$(BUNDLE_OVERLAP)/"* && \
	  ( if [ -w $(TRUNK)/bundle/openttd.cfg ]; then \
		sed '/version_string/ s!=.*$$!= HardPack-$(REV)!g' $(TRUNK)/bundle/openttd.cfg > openttd.cfg.tmp; \
		mv openttd.cfg.tmp $(TRUNK)/bundle/openttd.cfg; \
	   fi ) && \
	  echo '[BUNDLE] Customs copied from "$(BUNDLE_OVERLAP)"' || \
	true)
	@echo '[BUNDLE] Creating $(BUNDLE_NAME).tar.gz'
	$(Q)mkdir -p "$(BUNDLES_DIR)/.gzip/$(BUNDLE_NAME)"
	$(Q)cp -R    "$(BUNDLE_DIR)/"* "$(BUNDLES_DIR)/.gzip/$(BUNDLE_NAME)/"
	$(Q)cd "$(BUNDLES_DIR)/.gzip" && tar -zc$(shell if test -n "$(VERBOSE)"; then echo 'v'; fi)f "$(BUNDLES_DIR)/$(BUNDLE_NAME).tar.gz" "$(BUNDLE_NAME)"
	$(Q)rm -rf   "$(BUNDLES_DIR)/.gzip"

#( make $(MAKEFLAGS) -C "$(TRUNK)" bundle_zip )

descr : descr-start $(addsuffix .descr, $(PATCHES) )
	@echo "[/list]"

descr-start:
	@echo "[list=1]"

%.descr :
	@echo -n "	[*]"
	@awk '/^$*\>/ { $$1=""; printf "%s", $$0 }' patches.$(LANG).txt
	$(Q)( awk '/^$*\>/ { \
		if ( $$3 != "" ) { \
			if ( $$3 ~ /^http/ ) link = $$3; \
			else text = $$3; \
		} \
		if ( $$4 != "" ) { \
			if ( $$4 ~ /^http/ ) link = $$4; \
			else text = $$4; \
		} \
		if ( link != "" ) \
			printf " ([url=%s]%s [i]%s[/i][/url])", link, $$1, text; \
		else \
			printf " (%s [i]%s[/i])", $$1, text; \
	}' ${PATCHMAP} )
	@echo

	@( if [ "$*" == "leasing-with-build-and-refit" ]; then \
		$(MAKE) -f $(whoami) --no-print-directory $(addsuffix .descr, leasing build-and-refit ); \
	fi )
	@( if [ "$*" == "openttd-cargodist-sprinkles" ]; then \
		echo "		[list=1]"; \
		$(MAKE) -f $(whoami) --no-print-directory $(addsuffix .descr, cargo_dist variable-daylength Daily-autosave Vehicle-name-length ); \
		echo "		[/list]"; \
	fi )
	@( if [ "$*" == "harder-game" ]; then \
		echo "		[list=1]"; \
		$(MAKE) -f $(whoami) --no-print-directory $(addsuffix .descr, towncost infrastructure_maintenance building-costs additional-taxes vehicle-repair-cost); \
		echo "		[/list]"; \
	fi )
	@( if [ "$*" == "adv-orders" ]; then \
		$(MAKE) -f $(whoami) --no-print-directory $(addsuffix .descr, more-cond-orders stop-sharing  ); \
	fi )
		


	