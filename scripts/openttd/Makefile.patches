#
# Checking and applying patches against trunk or specified sources
# @author Andrey Zakharov /2010-2012/ http://vaultsoft.info
#

# Usage:
#  show patchpack patches list
#   make list
#  try to patch all patches
#   make
#  to check one by one set of patches
#   PATCHES="patch1 patch2" MODE=alone PARAM='' make
#  to make patchpack
#   PARAM='' make clean trunk-prepare all
#  make clean trunk-prepare && make PARAM='' all; make PARAM='' all


# untranslated strings
# awk '/^[^# ]/ {print $1}' english.txt | while read str; do grep -c $str russian.txt >/dev/null || echo $str;done

.PHONY : all clean trunk-prepare tp patching-building trunk-sweep trunk-clean trunk-update clean run pp

.NOTPARALLEL :

location = $(word $(words $(MAKEFILE_LIST)),$(MAKEFILE_LIST))
whoami := $(location)

#
#defaults
#
include Mk.params
# TODO openttd specific out to profiles?
PACKNAME ?= vs_hard_pack
LANG ?= ru
PARAM ?= "--dry-run"
TRUNK ?= $(HOME)/src/openttd/trunk
WORKDIR ?= ./
MODE ?= alone # or patchpack
#opens final result
BROWSER ?= cat
PATCHDIR ?= $(shell pwd)
PATCHMAP ?= $(PATCHDIR)/Mk.patchtable
PATCHES ?= $(shell cat patchpack.txt)
CONFIGURE_PARAMS +=
BUNDLE_OVERLAP ?= $(PATCHDIR)/../bundle
DOS2UNIXPATH ?= sed 's\#\\\\\#/\#g'
# TimeOut in secs
HTTP_TO ?= 30
DNS_TO ?= 2
DONE = @echo "==> $@ DONE"
FAILREPORT = ( ($(BROWSER) $< $@ &) && (find $(TRUNK) -name *.rej | xargs $(BROWSER) &) && ( grep "FAILED --" $< | $(BROWSER) )
Q ?= @
TRUNKTARGETREV ?= -rHEAD
REVERT_FIRST_CHUNK_IN = src/saveload/saveload.cpp

#
# Utils
#

# revision
VERSION := 0.8
# TODO as file REVISION.txt

#REV := $(shell cd ${TRUNK} && ./findversion.sh | awk '{ sub( /M/,"" , $$1 ); print $$1 }')
#REV := $(VERSION).$(shell cd ~/scripts/openttd && svnversion -n)
REV := $(VERSION).$(shell cd ${WORKDIR} && svnversion -n)
TRUNKREV := r$(shell cd ${TRUNK} && svnversion -n)
.PRECIOUS: ${PATCHDIR}/%.patch %.patch.log %.build.log ${PATCHDIR}/%.patch.${REV}

original_patch_name = $(shell echo "$@" | sed 's!_r[0-9]\+.*!.patch!')

#
# Gets the number of ignorable prefixes in unified patch
# Internal, skip this!
# 1. find "--- PATH"
# 2. see if this available
# 3. p++ goto 1
find_ignorable_prefix = $$(\
	for f in `awk '/^---(.*)$$/ { print $$2 }' $<`; do \
	 i=0; f2c="$$f"; \
	  if [ "x$$f2c" = "x/dev/null" ]; then continue; fi; \
	  if [ -r "${TRUNK}/$$f2c" ]; then echo $$i; exit 0; fi; \
	  while [ -n "$$f2c" ]; do \
	      i=`expr $$i + 1`; \
	      nf2c=`echo $$f2c | sed 's!^[^/]*/!!'`; \
	      if [ x"$$nf2c" = x"$$f2c" ]; then echo 0; exit 1; fi; \
	      f2c=$$nf2c; \
	      if [ -r "${TRUNK}/$$f2c" ]; then echo $$i; exit 0; fi; \
	  done; \
	done; )
# do it better by GNU make itself TODO

revert_savegame_version = (\
	cd "$(TRUNK)" && \
	if svn diff $(REVERT_FIRST_CHUNK_IN) | grep SAVEGAME_VERSION >/dev/null; then \
		svn diff $(REVERT_FIRST_CHUNK_IN) |\
			awk '/@@/ { c++; if (c == 2) exit  } { print $$0 }' |\
			patch --reverse --force $(REVERT_FIRST_CHUNK_IN); \
	fi; )

make_svn_diff = ( \
	cd "${TRUNK}" && \
	svn --diff-cmd diff --extensions '--unified --minimal --speed-large-files --ignore-space-change --ignore-all-space --show-c-function' \
		diff > "$@" )

# start of easy part
all : $(PACKNAME).patch.check ${PATCHDIR}/$(PACKNAME).patch.${REV}
	$(Q)( mv --force ${PATCHDIR}/$(PACKNAME).patch.${REV} ${PATCHDIR}/${VERSION}/$(PACKNAME).${REV}.${TRUNKREV}.patch )
	$(Q)( if arh=`which 7z`; then cd ${PATCHDIR}/${VERSION}/; $$arh a $(PACKNAME).${REV}.${TRUNKREV}.patch.7z $(PACKNAME).${REV}.${TRUNKREV}.patch; fi )
	@echo "==> $@ DONE"
	( $(BROWSER) ${PATCHDIR}/${VERSION}/$(PACKNAME).${REV}.${TRUNKREV}.patch )

$(TRUNK)/Makefile:
	( cd $(TRUNK); ./configure $(CONFIGURE_PARAMS) > /dev/null )

pp:
	$(Q)( make clean trunk-prepare )
#	is2 conflicts on leasing  export BROWSER=cat; 
	$(Q)( BROWSER=cat $(MAKE) all; $(MAKE) all )

# 
# Making auto patch file
# Do patch from current trunk
# $(PACKNAME).patch.${REV} will be caught by this
${PATCHDIR}/%.patch.${REV} : trunk-sweep trunk-generate
	$(Q)( cd $(TRUNK) && svn status | $(DOS2UNIXPATH) | grep -v ^\[M\|A\] |grep -v 'nbproject\|Makefile-trunk.mk\|bin/'|  awk '{print $$2}' | xargs svn add || true )
	$(Q)([ x"$*" != x"$(PACKNAME)" ]) && ${revert_savegame_version} || true
	$(Q)${make_svn_diff}

${PATCHDIR}/%.patch.${TRUNKREV}: trunk-sweep trunk-generate
	$(Q)( cd $(TRUNK) && svn status | $(DOS2UNIXPATH) | grep -v ^\[M\|A\] |grep -v 'nbproject\|Makefile-trunk.mk\|bin/'|  awk '{print $$2}' | xargs svn add || true )
	$(Q)${make_svn_diff}

# for quick hack, we do not require %.build.log 
%.save : ${PATCHDIR}/%.patch.${TRUNKREV} ${PATCHDIR}/%.patch.${REV} #alias
	$(Q)( mkdir -p ${PATCHDIR}/${VERSION}/ ) # mkdir ./patches/0.4
	$(Q)( mv --interactive ${PATCHDIR}/$*.patch.${TRUNKREV} ${PATCHDIR}/${VERSION}/$*.${TRUNKREV}.patch ) # mv p.patch.0.4.110 patches/0.4/p.patch.0.4.110
	$(Q)( mv --force ${PATCHDIR}/$*.patch.${REV} ${PATCHDIR}/${VERSION}/$*.${REV}.${TRUNKREV}.patch ) # mv p.patch.0.4.110 patches/0.4/p.patch.0.4.110
	$(Q)( cd ${PATCHDIR}; ln --symbolic --force ${VERSION}/$*.${REV}.${TRUNKREV}.patch $*.patch ) # sym link it
	$(Q)( ls -la ${PATCHDIR}/$*.patch )
	$(DONE)
#report here of diffs with previois patch

# override common rule by this one
#${PATCHDIR}/$(PACKNAME).patch.${REV} : ${PATCHDIR}/$(PACKNAME).build.log  trunk-sweep 

$(PACKNAME).build.log : patching-building reporting
	$(DONE)

##
# Preparing, cleaning & sweeping
#
tp :trunk-prepare

trunk-prepare  : trunk-sweep trunk-revert trunk-clean trunk-update #alias
	$(DONE)

trunk-revert : 
	$(Q)( cd $(TRUNK) && svn -R revert . )
	@echo [SRC] $(TRUNKREV) reverted

#sweep our mess
trunk-sweep:
	$(Q)( find $(TRUNK) -name \*rej -or -name \*orig -or -name \.~\*bak | xargs rm --force --verbose -- )
	@echo [SRC] $(TRUNKREV) swept

trunk-clean :
	$(Q)( if [ -f $(TRUNK)/Makefile ]; then $(MAKE) -f Makefile -C $(TRUNK) clean >/dev/null; fi )
#deep svn new files from patches clean
	$(Q)( cd $(TRUNK) && svn stat | $(DOS2UNIXPATH)  |  grep ^? | grep -v 'nbproject\|Makefile-trunk.mk\|bin/' | xargs rm -rf -- )
	@echo [SRC] $(TRUNKREV) clean

trunk-update : 
	$(Q)( cd $(TRUNK) && svn update $(TRUNKTARGETREV))
#    RVER=$(svnversion -n)

# generate project files
trunk-generate:
	$(Q)( cd $(TRUNK) && if [ -x projects/generate ]; then projects/generate; else /bin/bash projects/generate; fi )

post-patches-prepare:
	mkdir -p $(TRUNK).patched
	rsync -av --exclude=/bin --exclude=/docs --exclude=/objs --exclude=.svn --exclude=/nbproject --exclude=/bundle --exclude=/bundles --exclude='**.orig' --exclude-from=$(TRUNK)/.hgignore $(TRUNK)/ $(TRUNK).patched/

post-patches:
	diff -wur -x .dep.inc -x bin -x objs -x .svn -x nbproject -x bundle -x bundles -x *.orig $(TRUNK).patched/ --exclude-from=$(TRUNK)/.hgignore $(TRUNK)/ | grep -v -e Только -e Only

clean : 
	$(Q)( rm building *.log || true )
	$(DONE)

distclean : 
	( rm *.patch.$(REV) )
	$(DONE)

sweep : $(addsuffix .sweep, $(PATCHES) )
	$(DONE)

%.sweep :
	@echo "==> Sweeping $*..."
	$(Q)( rm ${PATCHDIR}/$*.patch || true )
	$(DONE)

run :
	$(MAKE) run -C $(TRUNK)

run-srv:
	$(TRUNK)/bin/openttd -D -f
	$(TRUNK)/bin/openttd -n 127.0.0.1:3979

reset: clean trunk-prepare
	$(DONE)

list :
	$(Q)( awk '/^[a-zA-Z]/ { print $$1 }' ${PATCHMAP} | tail -n+2|sort)

plan:
	$(Q)( echo $(PATCHES) )

# end of easy part

patchpack-versions: 
	( sed '/openttd_revision\[\]/ s!".*"!"HardPack-$(REV)"!g' $(TRUNK)/src/rev.cpp.in > rev.cpp.in.tmp )
	( mv rev.cpp.in.tmp $(TRUNK)/src/rev.cpp.in )

#
# Separate 
# * patchpack,
# * alone (patching and building patches alone one-by-one from list),
# * increment (patching and build-check one, then add next one, and so on
ifeq (${MODE},patchpack)
patching: $(addsuffix .patch.log, $(PATCHES)) patchpack-versions
	@echo "==> Patchpack patches DONE."

else ifeq (${MODE},alone)
patching: $(addprefix trunk-prepare ,$(addsuffix .patch.check, $(filter-out post-patches%,$(PATCHES)) ))
	@echo "==> Alone checking all patches DONE."

else
patching: $(addprefix increment ,$(addsuffix .patch.check, $(filter-out post-patches%,$(PATCHES)) ))
	@echo "==> Increment checking all patches DONE."

endif

building: $(TRUNK)/Makefile
	@echo "==> Buildin $*..."
ifeq ($(findstring --dry-run,${PARAM}),)
# changing dir for possible reconfigure, but we do not know initial path too
# also this is hack to pre-reconfigure by "make" not $(MAKE) which can be mingw32-make.exe
	( make $(MFLAGS) -C $(TRUNK) all >$@ )
else
	@echo "!!! Skipping /$(PARAM)/. To perform real build exec:"
	@echo "                  $$ PARAM=\"\" $(MAKE) all"
endif
	$(DONE)

# and all together
patching-building: patching building
	$(DONE)
# here construct txt report
reporting: 
	$(DONE)

increment :
	@echo "==> Incrementing..."

##
# Patchworks
#
%.patch.log : ${PATCHDIR}/%.patch
	@echo -n "==> Patchin $*..."
	$(Q)( test -f $< )
ifeq ($(findstring --dry-run,${PARAM}),)
	$(Q)( patch $(PARAM) --forward --force --fuzz=3 --directory="${TRUNK}" --strip=${find_ignorable_prefix} --input="$<" > $@ ) || \
		$(FAILREPORT) && false )
else
	$(Q)( patch $(PARAM) --forward --force --fuzz=3 --directory="${TRUNK}" --strip=${find_ignorable_prefix} --input="$<" )
endif
	@echo "OK"

# runs configure after patching? or not? who cares
%.build.log : %.patch.log $(TRUNK)/Makefile 
	@echo "==> Buildin $*..."
ifeq ($(findstring --dry-run,${PARAM}),)
# changing dir for possible reconfigure, but we do not know initial path too
#ifeq ($(findstring forceclean,${PARAM}),)
#	( $(MAKE) -C $(TRUNK) clean )
# also this is hack to pre-reconfigure by "make" not $(MAKE) which can be mingw32-make.exe
	$(Q)( make $(MFLAGS) -C $(TRUNK) all >$@ )
else
	@echo "!!! Skipping /$(PARAM)/. To perform real build exec:"
	@echo "                  $ PARAM=\"\" $(MAKE) all"
endif
	@echo "==> Buildin $* DONE"

%.patch.check : %.build.log ${PATCHDIR}/%.patch.${REV}
	$(DONE)



# Refresh patch file from its URL
#  here TODO from local saved file by currev-1,currev+1,currev-2,currev+2...
${PATCHDIR}/%.patch : 
	@echo "==> Refreshing $@..." 
	@( awk '/^$*/ { print $$3 }' ${PATCHMAP} )
	wget --output-document="$@" \
		--no-clobber --timeout=$(HTTP_TO) --dns-timeout=$(DNS_TO) --no-check-certificate -- \
		"$(shell awk '/^$*[ \t\n]+/ { print $$3 }' ${PATCHMAP})"


SRCDIR := $(shell dirname ${TRUNK})
%.new :
	( cd $(SRCDIR) && \
	  svn checkout svn://svn.openttd.org/tags/$*/ $* && \
	  echo "Don't forget to change TRUNK=\"$(SRCDIR)/$*\"!")
	 
BUNDLE_DIR =  $(TRUNK)/bundle
BUNDLES_DIR = $(TRUNK)/bundles
BUNDLE_NAME = openttd-hardpack-$(REV)
BUNDLE_OVERLAP_MACRO = ( \
	[ -n "$(BUNDLE_OVERLAP)" -a -d "$(BUNDLE_OVERLAP)" ] && \
		svn --force export $(BUNDLE_OVERLAP)/ $(TRUNK)/bundle && \
	  ( if [ -w $(TRUNK)/bundle/openttd.cfg ]; then \
		sed '/version_string/ s!=.*$$!= HardPack-$(REV)!g' $(TRUNK)/bundle/openttd.cfg > openttd.cfg.tmp; \
		mv openttd.cfg.tmp $(TRUNK)/bundle/openttd.cfg; \
	   fi ) && \
	  echo '[BUNDLE] Customs copied from "$(BUNDLE_OVERLAP)"' || \
	true)
bundle :
	@( make $(MFLAGS) -C "$(TRUNK)" bundle )
	$(BUNDLE_OVERLAP_MACRO)
	@echo '[BUNDLE] Creating $(BUNDLE_NAME).tar.gz'
	$(Q)mkdir -p "$(BUNDLES_DIR)/.gzip/$(BUNDLE_NAME)"
	$(Q)cp -R    "$(BUNDLE_DIR)/"* "$(BUNDLES_DIR)/.gzip/$(BUNDLE_NAME)/"
	$(Q)cd "$(BUNDLES_DIR)/.gzip" && tar -zc$(shell if test -n "$(VERBOSE)"; then echo 'v'; fi)f "$(BUNDLES_DIR)/$(BUNDLE_NAME).tar.gz" "$(BUNDLE_NAME)"
	$(Q)rm -rf   "$(BUNDLES_DIR)/.gzip"
	
bundle-win32:
	# should be already built to bin/openttd.exe
	@( make PLATFORM=Win32 $(MFLAGS) -C "$(TRUNK)" -f Makefile.msvc bundle )
	$(BUNDLE_OVERLAP_MACRO)
	@echo '[BUNDLE] Creating $(BUNDLE_NAME)-win32.7z'
	$(Q)mkdir -p "$(BUNDLES_DIR)/.7z/$(BUNDLE_NAME)"
	$(Q)cp -R    "$(BUNDLE_DIR)/"* "$(BUNDLES_DIR)/.7z/$(BUNDLE_NAME)/"
	$(Q)cd "$(BUNDLES_DIR)/.7z" && 7z a "$(BUNDLES_DIR)/$(BUNDLE_NAME)-win32.7z" "$(BUNDLE_NAME)"
	$(Q)rm -rf   "$(BUNDLES_DIR)/.7z"

bundle-x64:
	# should be already built to bin/openttd.exe
	@( make PLATFORM=x64 $(MFLAGS) -C "$(TRUNK)" -f Makefile.msvc bundle )
	$(BUNDLE_OVERLAP_MACRO)
	@echo '[BUNDLE] Creating $(BUNDLE_NAME)-x64.7z'
	$(Q)mkdir -p "$(BUNDLES_DIR)/.7z/$(BUNDLE_NAME)"
	$(Q)cp -R    "$(BUNDLE_DIR)/"* "$(BUNDLES_DIR)/.7z/$(BUNDLE_NAME)/"
	$(Q)cd "$(BUNDLES_DIR)/.7z" && 7z a "$(BUNDLES_DIR)/$(BUNDLE_NAME)-x64.7z" "$(BUNDLE_NAME)"
	$(Q)rm -rf   "$(BUNDLES_DIR)/.7z"

#( make $(MAKEFLAGS) -C "$(TRUNK)" bundle_zip )

descr : descr-start $(addsuffix .descr, $(PATCHES) )
	@echo "[/list]"

cat-descr: patches.cat.$(LANG).txt
	@echo "[list]"
	$(Q)( $(MAKE) -f $(whoami) --no-print-directory \
		$(addsuffix .cat-descr, $(shell awk '{print $$1}' patches.cat.$(LANG).txt )))
	@echo "[/list]"

%.cat-descr : patches.cat.$(LANG).txt patchpack.txt
	@echo -n "	[*] "
	$(Q)( awk '/^$*[ \t\n]+/ { for(i=2;i<=NF;i++) printf "%s ", $$i }' patches.cat.$(LANG).txt )
	@echo "		[list=1]"
	$(Q)( $(MAKE) -f $(whoami) --no-print-directory \
		$(addsuffix .descr, \
			$(shell awk '$$2 == "$*" { print $$1 }' $(PATCHMAP) | while read p; do grep -c $$p patchpack.txt >/dev/null && echo $$p; done ) \
		) \
	)
	@echo "		[/list][/*]"

descr-start:
	@echo "[list=1]"

%.descr : patches.$(LANG).txt
	@echo -n "	[*] "
	@awk '/^$*[ \t\n]+/ { $$1=""; printf "%s", $$0 }' patches.$(LANG).txt
	$(Q)( awk '/^$*[ \t\n]+/ { \
		if ( $$4 != "" ) { \
			if ( $$4 ~ /^http/ ) link = $$4; \
			else text = $$4; \
		} \
		if ( $$5 != "" ) { \
			if ( $$5 ~ /^http/ ) link = $$5; \
			else text = $$5; \
		} \
		if ( link != "" ) \
			printf " ([url=%s]%s [i]%s[/i][/url])", link, $$1, text; \
		else \
			printf " (%s [i]%s[/i])", $$1, text; \
	}' ${PATCHMAP} )
	@echo "[/*]"

	@( if [ "$*" = "grass-on-tracks-stuck-trains" ]; then \
		$(MAKE) -f $(whoami) --no-print-directory $(addsuffix .descr, grass-on-tracks stuck_trains ); \
	fi )
	@( if [ "$*" = "adv-orders" ]; then \
		$(MAKE) -f $(whoami) --no-print-directory $(addsuffix .descr, more-cond-orders stop-sharing  ); \
	fi )
