#
# Checking and applying patches against trunk or specified sources
# @author Andrey Zakharov /2010/
#
.PHONY : all clean trunk-prepare tp patching-building trunk-clean trunk-update clean run

.NOTPARALLEL :



#
#defaults
#
include Mk.params
# TODO openttd specific out to profiles?
PACKNAME=vs_hard_pack
LANG ?= ru
PARAM ?= "--dry-run"
TRUNK ?= $(HOME)/src/openttd/trunk
WORKDIR ?= ./
MODE ?= alone # or patchpack
BROWSER ?= cat #opens final result
PATCHDIR ?= $(shell pwd)
PATCHMAP ?= $(PATCHDIR)/Mk.patchtable
PATCHES ?= $(shell cat patchpack.txt)
CONFIGURE_PARAMS +=
BUNDLE_OVERLAP ?= $(PATCHDIR)/../bundle
DOS2UNIXPATH ?= sed 's\#\\\\\#/\#g'
# TimeOut in secs
HTTP_TO ?= 30
DNS_TO ?= 2
DONE = @echo "==> $@ DONE"
FAILREPORT = ( ($(BROWSER) $< $@ &) && (find $(TRUNK) -name *.rej | xargs $(BROWSER) &)
#
# Utils
#

# revision
VERSION := 0.3
# TODO as file REVISION.txt

#REV := $(shell cd ${TRUNK} && ./findversion.sh | awk '{ sub( /M/,"" , $$1 ); print $$1 }')
#REV := $(VERSION).$(shell cd ~/scripts/openttd && svnversion -n)
REV := $(VERSION).$(shell cd ${WORKDIR} && svnversion -n)
TRUNKREV := r$(shell cd ${TRUNK} && svnversion -n)
.PRECIOUS: ${PATCHDIR}/%.patch %.patch.log %.build.log ${PATCHDIR}/%.patch.${REV}

original_patch_name = $(shell echo "$@" | sed 's!_r[0-9]\+.*!.patch!')

#
# Gets the number of ignorable prefixes in unified patch
# Internal, skip this!
# 1. find "--- PATH"
# 2. see if this available
# 3. p++ goto 1
find_ignorable_prefix = $$(\
	for f in `awk '/^---(.*)$$/ { print $$2 }' $<`; do \
	  i=0; f2c="$$f"; \
	  if [ -r "${TRUNK}/$$f2c" ]; then echo $$i; exit 0; fi; \
	  while [ -n "$$f2c" ]; do \
	      i=`expr $$i + 1`; \
	      nf2c=`echo $$f2c | sed 's!^[^/]*/!!'`; \
	      if [ x"$$nf2c" = x"$$f2c" ]; then echo 0; exit 1; fi; \
	      f2c=$$nf2c; \
	      if [ -r "${TRUNK}/$$f2c" ]; then echo $$i; exit 0; fi; \
	  done; \
	done; )
# do it better by GNU make itself TODO

# start of easy part
all : $(PACKNAME).patch.check ${PATCHDIR}/$(PACKNAME).patch.${REV}
	@echo "==> $@ DONE"
	( $(BROWSER) ${PATCHDIR}/$(PACKNAME).patch.${REV} )

$(TRUNK)/Makefile:
	( cd $(TRUNK); ./configure $(CONFIGURE_PARAMS) > /dev/null )

# 
# Making auto patch file
# Do patch from current trunk
# $(PACKNAME).patch.${REV} will be caught by this
${PATCHDIR}/%.patch.${REV} : trunk-sweep trunk-generate
	( cd $(TRUNK) && svn status | $(DOS2UNIXPATH) | grep -v ^\[M\|A\] |grep -v 'nbproject\|Makefile-trunk.mk\|bin/'|  awk '{print $$2}' | xargs svn add || true )
	( cd ${TRUNK} && svn --extensions '--ignore-space-change --ignore-all-space' diff > "$@" )

# for quick hack, we do not require %.build.log 
%.save : ${PATCHDIR}/%.patch.${REV} #alias
	$(DONE)
#report here of diffs with previois patch

# override common rule by this one
#${PATCHDIR}/$(PACKNAME).patch.${REV} : ${PATCHDIR}/$(PACKNAME).build.log  trunk-sweep 

$(PACKNAME).build.log : patching-building reporting
	$(DONE)

##
# Preparing, cleaning & sweeping
#
tp :trunk-prepare

trunk-prepare  : trunk-sweep trunk-revert trunk-clean trunk-update #alias
	$(DONE)

trunk-revert : 
	( cd $(TRUNK) && svn -R revert . )

#sweep our mess
trunk-sweep:
	( find $(TRUNK) -name \*rej -or -name \*orig -or -name \.~\*bak | xargs rm --force --verbose )
	@echo $(TRUNKREV) was sweeped

trunk-clean :
	( if [ -f $(TRUNK)/Makefile ]; then $(MAKE) -f Makefile -C $(TRUNK) clean >/dev/null; fi )
#deep svn new files from patches clean
	( cd $(TRUNK) && svn stat | $(DOS2UNIXPATH)  |  grep ^? | grep -v 'nbproject\|Makefile-trunk.mk\|bin/' | xargs rm -rf )
	@echo $(REV)

trunk-update : 
	( cd $(TRUNK) && svn update )
#    RVER=$(svnversion -n)

# generate project files
trunk-generate:
	( cd $(TRUNK) && sh projects/generate )

clean : 
	( rm *.log || true )
	$(DONE)

distclean : 
	( rm *.patch.$(REV) )
	$(DONE)

sweep : $(addsuffix .sweep, $(PATCHES) )
	$(DONE)

%.sweep :
	@echo "==> Sweeping $*..."
	( rm ${PATCHDIR}/$*.patch || true )
	$(DONE)

run :
	$(MAKE) run -C $(TRUNK)

reset: clean trunk-prepare
	$(DONE)

list :
	@( awk '/^\w/ { print $$1 }' ${PATCHMAP} | tail -n+2|sort)

plan:
	@( echo $(PATCHES) )

# end of easy part

patchpack-versions: 
	( sed '/openttd_revision\[\]/ s!".*"!"HardPack-$(REV)"!g' $(TRUNK)/src/rev.cpp.in > rev.cpp.in.tmp )
	( mv rev.cpp.in.tmp $(TRUNK)/src/rev.cpp.in )
	( if [ -w $(BUNDLE_OVERLAP)/openttd.cfg ]; then \
		sed '/version_string/ s!=.*$$!= HardPack-$(REV)!g' $(BUNDLE_OVERLAP)/openttd.cfg > openttd.cfg.tmp; \
		mv openttd.cfg.tmp $(BUNDLE_OVERLAP)/openttd.cfg; \
	fi )

#
# Separate 
# * patchpack,
# * alone (patching and building patches alone one-by-one from list),
# * increment (patching and build-check one, then add next one, and so on
ifeq (${MODE},patchpack)

patching-building : $(addsuffix .patch.log, $(PATCHES) ) $(TRUNK)/Makefile patchpack-versions
	@echo "==> Buildin $*..."
ifeq ($(findstring --dry-run,${PARAM}),)
#	( $(MAKE) -C $(TRUNK) clean )
# changing dir for possible reconfigure, but we do not know initial path too
# also this is hack to pre-reconfigure by "make" not $(MAKE) which can be mingw32-make.exe
	( make $(MFLAGS) -C $(TRUNK) all >$@ )
else
	@echo "!!! Skipping /$(PARAM)/. To perform real build exec:"
	@echo "                  $$ PARAM=\"\" $(MAKE) all"
endif
	$(DONE)


else ifeq (${MODE},alone)
patching-building : $(addprefix trunk-prepare ,$(addsuffix .patch.check, $(PATCHES) ))
	@echo "==> Alone checking all patches DONE."


else
patching-building : $(addprefix increment ,$(addsuffix .patch.check, $(PATCHES) ))
	@echo "==> Increment checking all patches DONE."

endif

# here construct txt report
reporting: 
	$(DONE)

increment :
	@echo "==> Incrementing..."

##
# Patchworks
#
%.patch.log : ${PATCHDIR}/%.patch
	@echo -n "==> Patchin $*..."
	@( test -f $< )
ifeq ($(findstring --dry-run,${PARAM}),)
	@( patch $(PARAM) --directory=${TRUNK} --forward --force --fuzz=3 --strip=${find_ignorable_prefix} --input="$<" > $@ ) || \
		$(FAILREPORT) && false )
else
	@( patch $(PARAM) --directory=${TRUNK} --forward --force --fuzz=3 --strip=${find_ignorable_prefix} --input="$<" )
endif
	@echo "OK"

# runs configure after patching? or not? who cares
%.build.log : %.patch.log $(TRUNK)/Makefile 
	@echo "==> Buildin $*..."
ifeq ($(findstring --dry-run,${PARAM}),)
# changing dir for possible reconfigure, but we do not know initial path too
#ifeq ($(findstring forceclean,${PARAM}),)
#	( $(MAKE) -C $(TRUNK) clean )
# also this is hack to pre-reconfigure by "make" not $(MAKE) which can be mingw32-make.exe
	( make $(MFLAGS) -C $(TRUNK) all >$@ )
else
	@echo "!!! Skipping /$(PARAM)/. To perform real build exec:"
	@echo "                  $ PARAM=\"\" $(MAKE) all"
endif
	@echo "==> Buildin $* DONE"

%.patch.check : %.build.log ${PATCHDIR}/%.patch.${REV}
	$(DONE)



# Refresh patch file from its URL
#  here TODO from local saved file by currev-1,currev+1,currev-2,currev+2...
${PATCHDIR}/%.patch : 
	@echo "==> Refreshing $@..." 
	@( awk '/^$*/ { print $$2 }' ${PATCHMAP} )
	wget --output-document="$@" \
		--no-clobber --timeout=$(HTTP_TO) --dns-timeout=$(DNS_TO) -- \
		"$(shell awk '/^$*[ ]+/ { print $$2 }' ${PATCHMAP})"


SRCDIR := $(shell dirname ${TRUNK})
%.new :
	( cd $(SRCDIR) && \
	  svn checkout svn://svn.openttd.org/tags/$*/ $* && \
	  echo "Don't forget to change TRUNK=\"$(SRCDIR)/$*\"!")
	 
BUNDLE_DIR =  $(TRUNK)/bundle
BUNDLES_DIR = $(TRUNK)/bundles
BUNDLE_NAME = openttd-hardpack-$(REV)
bundle :
	@( make $(MFLAGS) -C "$(TRUNK)" bundle )
	( [ -n "$(BUNDLE_OVERLAP)" -a -d "$(BUNDLE_OVERLAP)" ] && \
	  cp -R --force --target-directory="$(TRUNK)/bundle" "$(BUNDLE_OVERLAP)/"* && \
	  echo '[BUNDLE] Customs copied from "$(BUNDLE_OVERLAP)"' || \
	true)
	@echo '[BUNDLE] Creating $(BUNDLE_NAME).tar.gz'
	$(Q)mkdir -p "$(BUNDLES_DIR)/.gzip/$(BUNDLE_NAME)"
	$(Q)cp -R    "$(BUNDLE_DIR)/"* "$(BUNDLES_DIR)/.gzip/$(BUNDLE_NAME)/"
	$(Q)cd "$(BUNDLES_DIR)/.gzip" && tar -zc$(shell if test -n "$(VERBOSE)"; then echo 'v'; fi)f "$(BUNDLES_DIR)/$(BUNDLE_NAME).tar.gz" "$(BUNDLE_NAME)"
	$(Q)rm -rf   "$(BUNDLES_DIR)/.gzip"

#( make $(MAKEFLAGS) -C "$(TRUNK)" bundle_zip )

descr : descr-start $(addsuffix .descr, $(PATCHES) )
	@echo "[/list]"

descr-start:
	@echo "[list=1]"	

%.descr :
	@echo -n "	[*]"
	@awk '/^$*\>/ { $$1=""; printf "%s", $$0 }' patches.$(LANG).txt
	@awk '/^$*\>/ { if ($$3!="") printf " ([url=%s]%s[/url])", $$3, $$1 }' ${PATCHMAP}
	@echo
	@( if [ "$*" == "openttd-cargodist-sprinkles" ]; then \
		echo "		[list=1]"; \
		$(MAKE) --no-print-directory $(addsuffix .descr, cargo_dist variable-daylength Daily-autosave Vehicle-name-length ); \
		echo "		[/list]"; \
	fi )
	@( if [ "$*" == "harder-game" ]; then \
		echo "		[list=1]"; \
		$(MAKE) --no-print-directory $(addsuffix .descr, towncost infrastructure_maintenance building-costs additional-taxes vehicle-repair-cost town-cargo-factor); \
		echo "		[/list]"; \
	fi )
	@( if [ "$*" == "adv-orders" ]; then \
		echo "		[list=1]"; \
		$(MAKE) --no-print-directory $(addsuffix .descr, more-cond-orders stop-sharing  ); \
		echo "		[/list]"; \
	fi )
		


	